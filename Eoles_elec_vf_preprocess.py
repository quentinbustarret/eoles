# -*- coding: utf-8 -*-

"""
Eoles Model from Behrang Shirizadeh, Quentin Perrier and Philippe Quirion, May 2021
Written in Python by Nilam De Oliveira-Gill, June 2021
Correction for nuclear flexibility by Quentin Bustarret, August 2022
"""

"""IMPORTS

Import modules and libraries needed for the programm 
"""

import pyomo.environ as pyo
from pyomo.opt import SolverFactory
import pandas as pd
import csv
import time
import sys
from CONFIG import model_name, nb_years

#Initialize time to measure the execution time
start_time = time.time()

input_years = ""
if nb_years == 1:
    input_years = "2006"
elif nb_years == 2:
    input_years = "2006_2004"
elif nb_years == 3:
    input_years = "2006_2004_2011"
elif nb_years == 20:
    input_years = "2000-2019"
else:
    raise ValueError("The number of years must be 1, 2, 3 or 20. Please change the value in the CONFIG.py file")

"""INITIALISATION OF THE MODEL"""

model = pyo.ConcreteModel()

#Dual Variable, used to get the marginal value of an equation.
model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)

"""INPUTS"""

    # Production profiles of VRE
load_factor = pd.read_csv("inputs/vre_profiles_"+input_years+".csv", index_col=[0, 1], header=None).squeeze("columns")
    # Demand profile at each hour in GW
demand_1y = pd.read_csv("inputs/demand2050_RTE.csv",index_col=0, header=None).squeeze("columns")
demand=demand_1y
for i in range(nb_years-1):
    demand = pd.concat([demand, demand_1y], ignore_index=True)
    # Monthly lake inflows in GWh
lake_inflows = pd.read_csv("inputs/lake_"+input_years+".csv", index_col=0, header=None).squeeze("columns")
    # Additional FRR requirement for variable renewable energies because of forecast errors
epsilon = pd.read_csv("inputs/reserve_requirements_new.csv", index_col=0, header=None).squeeze("columns")
    # Existing capacities of the technologies by December 2017 in GW
existing_capa = pd.read_csv("inputs/existing_capas_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Maximum capacities of the technologies in GW
capa_max = pd.read_csv("inputs/max_capas_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Fixed capacities of the technologies in GW
fix_capa = pd.read_csv("inputs/fix_capas.csv", index_col=0, header=None).squeeze("columns")
    # Expected lifetime in years
lifetime = pd.read_csv("inputs/lifetime.csv", index_col=0, header=None).squeeze("columns")
    # Construction time in years
construction_time = pd.read_csv("inputs/construction_time.csv", index_col=0, header=None).squeeze("columns")
    # Overnight capex cost in M€/GW
capex = pd.read_csv("inputs/overnight_capex.csv", index_col=0, header=None).squeeze("columns")    
    # Energy capex cost fo storage technologies in M€/GWh
storage_capex = pd.read_csv("inputs/storage_capex.csv", index_col=0, header=None).squeeze("columns")
    # Annualized fixed operation and maintenance costs M€/GW/year
fOM = pd.read_csv("inputs/fO&M_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Variable operation and maintenance costs in M€/GWh
vOM = pd.read_csv("inputs/vO&M_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Charging related annuity of storage in M€/GW/year
charging_capex = pd.read_csv("inputs/charging_capex.csv", index_col=0, header=None).squeeze("columns")
    # Charging related fOM of storage in M€/GW/year
charging_opex = pd.read_csv("inputs/charging_opex.csv", index_col=0, header=None).squeeze("columns")
    # Charging efficiency of storage technologies
eta_in = pd.read_csv("inputs/eta_in.csv", index_col=0, header=None).squeeze("columns")
    # Discharging efficiency of storage technologies
eta_out = pd.read_csv("inputs/eta_out.csv", index_col=0, header=None).squeeze("columns")
    # Existing storage capacity in GWh
capacity_ex = pd.read_csv("inputs/capacity_ex.csv", index_col=0, header=None).squeeze("columns")
    #Parameters in miscellaneous.csv :
        # eta_ocgt                          : efficiency of OCGT power plants
        # eta_ccgt                          : efficiency of CCGT power plants
        # eta_h2_ccgt                       : efficiency of H2 CCGT power plants
        # eta_methanation                   : efficiency of methanation
        # eta_electrolysis                  : efficiency of Electrolysis
        # max_biogas                        : maximum energy can be generated by biogas in TWh
        # load_uncertainty                  : uncertainty coefficient for hourly demand
        # delta                             : load variation factor
        # H2_demand                         : hourly hydrogen demand on top of the storage for use in industry and transportation
        # CH4_demand                        : hourly methane demand on top of the storage for use in industry and transportation
        # phs_discharging_lower             : lower bounds for capa(phs)
        # phs_discharging_upper             : upper bounds for capa(phs)
        # phs_charging_lower                : lower bounds for s(phs) 
        # phs_charging_upper                : upper bounds for s(phs)
        # phs_energy_lower                  : lower bounds for capacity(phs)
        # phs_energy_upper                  : upper bounds for capacity(phs)
        # first_month                       : first month of demand
        # hourly_ramping_nuc                : hourly ramp rate for nuclear production, i.e. maximal % of nominal power of increase/decrease in production 
        # len_delay                         : minimal length of shutdown during irradiation period for nuclear power plants, in hours 
        # percentage_co2_from_methanization : percentage of CO2 produced from biogas used in methanation, relative to the quantity of methane produced by biogas
        # discount_rate                     : discount rate. The recommended value by the French government for use in public socio-economic analyses is 4.5%

miscellaneous = pd.read_csv("inputs/miscellaneous.csv", index_col=0, header=None).squeeze("columns")

    # Annualized power capex cost for each tec in M€/GW/year. Formula found in "Low-carbon options for the French power sector: What role for renewables, nuclear energy and carbon capture and storage?", Behrang Shirizadeh & Philippe Quirion, Energy Economics
annuities = pd.read_csv("inputs/construction_time.csv", index_col=0, header=None).squeeze("columns")
for i in annuities.index:
    annuities.at[i] = miscellaneous["discount_rate"]*capex[i]*(miscellaneous["discount_rate"]*construction_time[i]+1)/(1-(1+miscellaneous["discount_rate"])**(-lifetime[i]))

    # Annualized energy capex cost of storage technologies in M€/GWh/year   
storage_annuities = pd.read_csv("inputs/storage_capex.csv", index_col=0, header=None).squeeze("columns")
for i in storage_annuities.index:
    storage_annuities.at[i] = miscellaneous["discount_rate"]*storage_capex[i]*(miscellaneous["discount_rate"]*construction_time[i]+1)/(1-(1+miscellaneous["discount_rate"])**(-lifetime[i]))

"""SET HOUR BY MONTHS

Take the number of hour in the demand file.
Set up hours per months."""

first_month = miscellaneous['first_month']
first_hour = 0
last_hour = len(demand)

hours_by_months = {1: 744, 2: 672, 3: 744, 4: 720, 5: 744, 6: 720, 7: 744, 8: 744, 9: 720, 10: 744, 11: 720, 12: 744}

months_hours = {1: range(0, hours_by_months[first_month])}

j = first_month+1
for i in range(2, 12*nb_years+1):
    hour=months_hours[i-1][-1]+1
    months_hours[i] = range(hour,hour+hours_by_months[j])
    j += 1
    if j == 13:
        j = 1

"""SETS

Definition of set as an object of the model
"""

#Range of hour
model.h = \
    pyo.RangeSet(first_hour,last_hour-1)
#Months
model.months = \
    pyo.RangeSet(1,12*nb_years)
#Technologies
model.tec = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake", "biogas1", "biogas2", "ocgt", "ccgt", "nuc", "h2_ccgt", "phs",  "battery1", "battery4", "methanation", "pyrogazification", "electrolysis", "hydrogen", "methane"])
#Power plants. Only used to calculate sum of generation.
model.gen = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake", "ocgt", "ccgt", "nuc"])
#Variables Technologies
model.vre = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river"])
#Electricity generating technologies
model.balance = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake","nuc","phs","battery1","battery4","h2_ccgt","ocgt","ccgt"])
#Storage Technologies
model.str = \
    pyo.Set(initialize=["phs","battery1","battery4","hydrogen","methane"])
#Battery Storage
model.battery = \
    pyo.Set(initialize=["battery1","battery4"])
#Technologies for upward FRR
model.frr = \
    pyo.Set(initialize=["lake", "phs", "ocgt","ccgt","nuc","h2_ccgt"])

#Dictionnaries which will set a little definition and unit for each technology in the model.
technologies_definition = {
    "offshore_f" : "floating offshore wind",
    "offshore_g" : "ground-based offshore wind",
    "onshore" : "onshore wind", 
    "pv_g" : "pv grounded",
    "pv_c" : "pv commercial",
    "river" : "run-of-river hydro",
    "lake" : "lake and reservoirs",
    "biogas1" : "biogas for ocgt",
    "biogas2" : "biogas for ccgt",
    "ocgt" : "open cycle gas-turbine",
    "ccgt" : "combined cycle gas turbine",
    "nuc" : "nuclear",
    "h2_ccgt" : "combined cycle gas turbine using hydrogen",
    "phs" : "pumped hydroelectric energy storage",
    "battery1" : "1 hour battery",
    "battery4" : "4 hours battery",
    "methanation" : "methane by methanation, into storage",
    "pyrogazification" : "methane by pyrogazification, into storage",
    "electrolysis" : "electrolysis",
    "hydrogen" : "hydrogen removed from storage",
    "methane" : "methane removed from storage",
}

technologies_units = {
    "offshore_f" : "GWh-e",
    "offshore_g" : "GWh-e",
    "onshore": "GWh-e",
    "pv_g" : "GWh-e",
    "pv_c" : "GWh-e",
    "river" : "GWh-e",
    "lake" : "GWh-e",
    "biogas1" : "GWh-th",
    "biogas2" : "GWh-th",
    "ocgt" : "GWh-e",
    "ccgt" : "GWh-e",
    "nuc" : "GWh-e",
    "h2_ccgt" : "GWh-e",
    "phs" : "GWh-e",
    "battery1" : "GWh-e",
    "battery4" : "GWh-e",
    "methanation" : "GWh-th",
    "pyrogazification" : "GWh-th",
    "electrolysis" : "GWh-th",
    "hydrogen" : "GWh-th",
    "methane" : "GWh-th",
}

"""PARAMETERS"""

#Set the hydrogen demand for each hour
H2_demand = {}
for hour in model.h:
    H2_demand[hour] = miscellaneous['H2_demand']

#Set the methane demand for each hour
CH4_demand = {}
for hour in model.h:
    CH4_demand[hour] = miscellaneous['CH4_demand']


"""BOUNDS VALUES

Set initial value for variables.
There is a function for each variable with bounds.
The function return the lower and the upper value.
"""

def capa_bounds(model,i):
    if i in capa_max.keys():
        return (None,capa_max[i])
    elif i == 'phs' :
        return (miscellaneous['phs_discharging_lower'],miscellaneous['phs_discharging_upper'])
    else :
        return(None,None)

def s_bounds(model,i):
    if i == 'phs' :
        return (miscellaneous['phs_charging_lower'],miscellaneous['phs_charging_upper'])
    else :
        return (None,None)

def capacity_bounds(model,i):
    if i == 'phs' :
        return (miscellaneous['phs_energy_lower'],miscellaneous['phs_energy_upper'])
    elif i == 'hydrogen' :
        return (capacity_ex['hydrogen'],None)
    else :
        return (None,None)

"""VARIABLES

Definition of variable as an object of the model
"""

    # Hourly energy generation in GWh/h
model.gene = \
    pyo.Var(((tec, h) for tec in model.tec for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Overall yearly installed capacity in GW
model.capa = \
    pyo.Var(model.tec, within=pyo.NonNegativeReals, bounds=capa_bounds)

    # Hourly electricity input of battery storage GW
model.storage = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Energy stored in each storage technology in GWh = Stage of charge
model.stored = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Charging power capacity of each storage technology
model.s = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, bounds=capa_bounds)

    # Energy volume of storage technology in GWh
model.capacity = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, bounds = capacity_bounds)

    # Required upward frequency restoration reserve in GW    
model.reserve = \
    pyo.Var(((reserve, h) for reserve in model.frr for h in model.h), within=pyo.NonNegativeReals,initialize=0)

"""FIXED VALUES"""

for tec in model.tec:
    if tec in fix_capa.keys():
        model.capa[tec].fix(fix_capa[tec])

"""CONSTRAINTS RULE

Set up a function which will return the equation of the constraint.
"""

def generation_vre_constraint_rule(model, h, vre):
    """Get constraint on variables renewable profiles generation."""

    return model.gene[vre, h] == model.capa[vre] * load_factor[vre,h]

def generation_capacity_constraint_rule(model, h, tec):
    """Get constraint on maximum power for non-VRE technologies."""

    return model.capa[tec] >= model.gene[tec,h]

def battery1_capacity_constraint_rule(model):
    """Get constraint on capacity of battery1."""

    return model.capa['battery1'] == model.capacity['battery1']

def battery4_capacity_constraint_rule(model):
    """Get constraint on capacity of battery4."""

    return model.capa['battery4'] == model.capacity['battery4']/4

def frr_capacity_constraint_rule(model, h, frr):
    """Get constraint on maximum generation including reserves"""

    return model.capa[frr] >= model.gene[frr, h] + model.reserve[frr, h]

def storing_constraint_rule(model, h, storage_tecs):
    """Get constraint on storing."""

    hPOne = h+1 if h<(last_hour-1) else 0
    charge = model.storage[storage_tecs, h] * eta_in[storage_tecs]
    discharge =  model.gene[storage_tecs, h] / eta_out[storage_tecs]
    flux = charge - discharge
    return model.stored[storage_tecs, hPOne] == model.stored[storage_tecs, h] + flux

def storage_constraint_rule(model,storage_tecs):
    """Get constraint on stored energy to be equal at the end than at the start."""

    first = model.stored[storage_tecs, first_hour]
    last = model.stored[storage_tecs, last_hour-1]
    charge = model.storage[storage_tecs, last_hour-1] * eta_in[storage_tecs]
    discharge = model.gene[storage_tecs, last_hour-1] / eta_out[storage_tecs]
    flux = charge - discharge
    return first == last + flux

def lake_reserve_constraint_rule(model, month):
    """Get constraint on maximum monthly lake generation."""

    return sum(model.gene['lake', hour] for hour in months_hours[month]) <= lake_inflows[month] * 1000

def stored_capacity_constraint(model, h, storage_tecs):
    """Get constraint on maximum energy that is stored in storage units"""

    return model.stored[storage_tecs, h] <= model.capacity[storage_tecs]

def storage_capacity_1_constraint_rule(model, h, storage_tecs):
    """Get constraint on the capacity with hourly charging relationship of storage"""

    return model.s[storage_tecs] >= model.storage[storage_tecs, h]

def battery_capacity_constraint_rule(model,battery):
    """Get constraint on battery's capacity."""

    return model.s[battery] == model.capa[battery]

def biogas_constraint_rule(model):
    """Get constraint on biogas."""

    gene_biogas = sum(model.gene['biogas1', hour]+model.gene['biogas2',hour] for hour in model.h)

    return gene_biogas <= miscellaneous['max_biogas'] * 1000

def hydrogen_balance_constraint_rule(model,h):
    """Get constraint on hydrogen's balance."""

    gene_e_h = model.gene['electrolysis',h]+model.gene['hydrogen',h]
    dem_sto = model.gene['h2_ccgt',h]/miscellaneous['eta_h2_ccgt'] + H2_demand[h] + model.storage['hydrogen',h] + model.gene['methanation',h]*4/miscellaneous['eta_methanation'] #4 h2 are required to produce one CH4
    return gene_e_h == dem_sto

def methane_balance_constraint_rule(model,h):
    """Get constraint on methane's balance."""

    gene_methane = model.gene['methanation',h] + model.gene['biogas1',h] + model.gene['biogas2',h] + model.gene['pyrogazification', h] + model.gene['methane',h]
    dem_sto = model.gene['ocgt',h]/miscellaneous['eta_ocgt'] + model.gene['ccgt',h]/miscellaneous['eta_ccgt'] + CH4_demand[h] + model.storage['methane', h]
    return gene_methane == dem_sto

def reserves_constraint_rule(model, h):
    """Get constraint on frr reserves"""

    res_req = sum(epsilon[vre] * model.capa[vre] for vre in model.vre)
    load_req = demand[h] * miscellaneous['load_uncertainty'] * (1 + miscellaneous['delta'])
    return sum(model.reserve[frr, h] for frr in model.frr) ==  res_req + load_req

def adequacy_constraint_rule(model, h):
    """Get constraint for 'supply/demand relation'"""

    storage = sum(model.storage[str, h] for str in model.str if (str != "hydrogen" and str != "methane"))
    gene_electrolysis = model.gene['electrolysis',h] / miscellaneous['eta_electrolysis']
    return sum(model.gene[balance, h] for balance in model.balance) >= (demand[h] + storage + gene_electrolysis)

def ramping_nuc_up_constraint_rule(model, h):
    """Sets an upper ramping limit for nuclear flexibility"""

    old_h = model.h.last() if h==0 else h-1
    return model.gene['nuc',h] - model.gene['nuc',old_h] + model.reserve['nuc',h] - model.reserve['nuc',old_h] <= miscellaneous['hourly_ramping_nuc']*model.capa['nuc']

def ramping_nuc_down_constraint_rule(model, h):
    """Sets a lower ramping limit for nuclear flexibility"""

    old_h = model.h.last() if h==0 else h-1
    return model.gene['nuc',old_h] - model.gene['nuc',h] + model.reserve['nuc',old_h] - model.reserve['nuc',h] <= miscellaneous['hourly_ramping_nuc']*model.capa['nuc']

def methanation_constraint_rule(model, h):
    """Get constraint on CO2's balance from methanization"""

    return model.gene['methanation', h]/miscellaneous['eta_methanation'] <= (model.gene['biogas1', h] + model.gene['biogas2', h]) * miscellaneous['percentage_co2_from_methanization']

def objective_rule(model):
    """Get constraint for the final objective function."""

    return (sum((model.capa[tec] - existing_capa[tec]) * annuities[tec] * nb_years for tec in model.tec) \
           + sum((model.capacity[storage_tecs]-capacity_ex[storage_tecs]) * storage_annuities[storage_tecs] * nb_years for storage_tecs in model.str) \
           + sum(model.capa[tec] * fOM[tec] * nb_years for tec in model.tec) \
           + sum(model.s[storage_tecs] * (charging_opex[storage_tecs] + charging_capex[storage_tecs]) * nb_years for storage_tecs in model.str) \
           + sum(sum(model.gene[tec, h] * vOM[tec] for h in model.h) for tec in model.tec) \
           )/1000

"""CONSTRAINT CREATION

Create the constraint as an object of the model with the function declared earlier as a rule.
"""

model.generation_vre_constraint = \
    pyo.Constraint(model.h, model.vre, rule=generation_vre_constraint_rule)

model.generation_capacity_constraint = \
    pyo.Constraint(model.h, model.tec, rule=generation_capacity_constraint_rule)

model.battery_1_capacity_constraint = \
    pyo.Constraint(rule=battery1_capacity_constraint_rule)

model.battery_4_capacity_constraint = \
    pyo.Constraint(rule=battery4_capacity_constraint_rule)

model.frr_capacity_constraint = \
    pyo.Constraint(model.h, model.frr, rule=frr_capacity_constraint_rule)

model.storing_constraint = \
    pyo.Constraint(model.h,model.str, rule=storing_constraint_rule)

model.storage_constraint = \
    pyo.Constraint(model.str, rule=storage_constraint_rule)

model.lake_reserve_constraint = \
    pyo.Constraint(model.months, rule=lake_reserve_constraint_rule)

model.stored_capacity_constraint = \
    pyo.Constraint(model.h, model.str, rule=stored_capacity_constraint)

model.storage_capacity_1_constraint = \
    pyo.Constraint(model.h, model.str, rule=storage_capacity_1_constraint_rule)

model.battery_capacity_constraint = \
    pyo.Constraint(model.battery, rule=battery_capacity_constraint_rule)

model.biogas_constraint = \
    pyo.Constraint(rule=biogas_constraint_rule)

model.hydrogen_balance_constraint = \
    pyo.Constraint(model.h,rule=hydrogen_balance_constraint_rule)

model.methane_balance_constraint = \
    pyo.Constraint(model.h,rule=methane_balance_constraint_rule)

model.reserves_constraint = \
    pyo.Constraint(model.h, rule=reserves_constraint_rule)

model.adequacy_constraint = \
    pyo.Constraint(model.h, rule=adequacy_constraint_rule)

model.ramping_nuc_up_constraint = \
    pyo.Constraint(model.h, rule=ramping_nuc_up_constraint_rule)

model.ramping_nuc_down_constraint= \
    pyo.Constraint(model.h, rule=ramping_nuc_down_constraint_rule)

model.methanation_constraint = \
    pyo.Constraint(model.h, rule=methanation_constraint_rule)

#Creation of the objective -> Cost
model.objective = pyo.Objective(rule=objective_rule)

"""SOLVE STATEMENT

Choice of the solver.
You can remove the '#' in the third line to display the output of the solver.
"""

opt = SolverFactory('gurobi')
results = opt.solve(model, options={'Presolve':2, 'LogFile':"grblogfile_pre_"+model_name})
#model.display()

"""OUTPUTS
    There is 1 output files in the preprocess :
        - Hourly_deficit    : hourly deficit of production + NPP capacity
    These will be used by the Eoles_nuc_opti module, then deleted

The try, except loop is here the manage error in the creation of the outputs.
"""

# Hourly deficit
hourly_file = "outputs/eoles_" + model_name + "_hourly_deficit_prod.csv"
try:
    with open(hourly_file,"w",newline="") as hourly:
        hourly_writer = csv.writer(hourly)
        hourly_writer.writerow(["hour", "deficit", "nuc_capa"])
        for hour in model.h:
            hourly_data = [hour]
            deficit=demand[hour]-sum(model.gene[vre, hour] for vre in model.vre)
            hourly_data.append(round(pyo.value(deficit),2))
            if hour==0: hourly_data.append(round(pyo.value(model.capa['nuc']),2))
            hourly_writer.writerow(hourly_data)
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : "+hourly_file) 
    else : 
        print("There is an Error (hourly) : "+e.args[0])

print("Execution time (preprocess): " + str(round(time.time() - start_time, 2)) + "s")
