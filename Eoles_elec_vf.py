# -*- coding: utf-8 -*-

"""
Eoles Model from Behrang Shirizadeh, Quentin Perrier and Philippe Quirion, May 2021
Written in Python by Nilam De Oliveira-Gill, June 2021
Correction for nuclear flexibility by Quentin Bustarret, August 2022
"""

"""IMPORTS

Import modules and libraries needed for the programm 
"""

import pyomo.environ as pyo
from pyomo.opt import SolverFactory
import pandas as pd
import csv
import time
import sys
from CONFIG import model_name, nb_years

#Initialize time to measure the execution time
start_time = time.time()

input_years = ""
if nb_years == 1:
    input_years = "2006"
elif nb_years == 2:
    input_years = "2006_2004"
elif nb_years == 3:
    input_years = "2006_2004_2011"
elif nb_years == 20:
    input_years = "2000-2019"
else:
    raise ValueError("The number of years must be 1, 2, 3 or 20. Please change the value in the CONFIG.py file")

"""INITIALISATION OF THE MODEL"""

model = pyo.ConcreteModel()

#Dual Variable, used to get the marginal value of an equation.
model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)

"""INPUTS"""

    # Production profiles of VRE
load_factor = pd.read_csv("inputs/vre_profiles_"+input_years+".csv", index_col=[0, 1], header=None).squeeze("columns")
    # Demand profile at each hour in GW
demand_1y = pd.read_csv("inputs/demand2050_RTE.csv",index_col=0, header=None).squeeze("columns")
demand=demand_1y
for i in range(nb_years-1):
    demand = pd.concat([demand, demand_1y], ignore_index=True)
    # Monthly lake inflows in TWh
lake_inflows = pd.read_csv("inputs/lake_"+input_years+".csv", index_col=0, header=None).squeeze("columns")
    # Additional FRR requirement for variable renewable energies because of forecast errors
epsilon = pd.read_csv("inputs/reserve_requirements_new.csv", index_col=0, header=None).squeeze("columns")
    # Existing capacities of the technologies by December 2017 in GW
existing_capa = pd.read_csv("inputs/existing_capas_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Maximum capacities of the technologies in GW
capa_max = pd.read_csv("inputs/max_capas_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Fixed capacities of the technologies in GW
fix_capa = pd.read_csv("inputs/fix_capas.csv", index_col=0, header=None).squeeze("columns")
    # Expected lifetime in years
lifetime = pd.read_csv("inputs/lifetime.csv", index_col=0, header=None).squeeze("columns")
    # Construction time in years
construction_time = pd.read_csv("inputs/construction_time.csv", index_col=0, header=None).squeeze("columns")
    # Overnight capex cost in M€/GW
capex = pd.read_csv("inputs/overnight_capex.csv", index_col=0, header=None).squeeze("columns")    
    # Energy capex cost fo storage technologies in M€/GWh
storage_capex = pd.read_csv("inputs/storage_capex.csv", index_col=0, header=None).squeeze("columns")
    # Annualized fixed operation and maintenance costs M€/GW/year
fOM = pd.read_csv("inputs/fO&M_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Variable operation and maintenance costs in M€/GWh
vOM = pd.read_csv("inputs/vO&M_elec_new.csv", index_col=0, header=None).squeeze("columns")
    # Charging related annuity of storage in M€/GW/year
charging_capex = pd.read_csv("inputs/charging_capex.csv", index_col=0, header=None).squeeze("columns")
    # Charging related fOM of storage in M€/GW/year
charging_opex = pd.read_csv("inputs/charging_opex.csv", index_col=0, header=None).squeeze("columns")
    # Charging efficiency of storage technologies
eta_in = pd.read_csv("inputs/eta_in.csv", index_col=0, header=None).squeeze("columns")
    # Discharging efficiency of storage technologies
eta_out = pd.read_csv("inputs/eta_out.csv", index_col=0, header=None).squeeze("columns")
    # Existing storage capacity in GWh
capacity_ex = pd.read_csv("inputs/capacity_ex.csv", index_col=0, header=None).squeeze("columns")
    # The maximal operating capacity due to nuclear planned outages in GW
nuc_max_operating_capa = pd.read_csv("inputs/maximal_operating_capacity_"+str(nb_years)+"y.csv", index_col=0, header=None).squeeze("columns")
    # The minimal operating capacity due to nuclear planned outages in GW
nuc_min_operating_capa = pd.read_csv("inputs/minimal_operating_capacity_"+str(nb_years)+"y.csv", index_col=0, header=None).squeeze("columns")
    #Parameters in miscellaneous.csv :
        # eta_ocgt                          : efficiency of OCGT power plants
        # eta_ccgt                          : efficiency of CCGT power plants
        # eta_h2_ccgt                       : efficiency of H2 CCGT power plants
        # eta_methanation                   : efficiency of methanation
        # eta_electrolysis                  : efficiency of Electrolysis
        # max_biogas                        : maximum energy can be generated by biogas in TWh
        # load_uncertainty                  : uncertainty coefficient for hourly demand
        # delta                             : load variation factor
        # H2_demand                         : hourly hydrogen demand on top of the storage for use in industry and transportation
        # CH4_demand                        : hourly methane demand on top of the storage for use in industry and transportation
        # phs_discharging_lower             : lower bounds for capa(phs)
        # phs_discharging_upper             : upper bounds for capa(phs)
        # phs_charging_lower                : lower bounds for s(phs) 
        # phs_charging_upper                : upper bounds for s(phs)
        # phs_energy_lower                  : lower bounds for capacity(phs)
        # phs_energy_upper                  : upper bounds for capacity(phs)
        # first_month                       : first month of demand
        # hourly_ramping_nuc                : hourly ramp rate for nuclear production, i.e. maximal % of nominal power of increase/decrease in production 
        # len_delay                         : minimal length of shutdown during irradiation period for nuclear power plants, in hours 
        # percentage_co2_from_methanization : percentage of CO2 produced from biogas used in methanation, relative to the quantity of methane produced by biogas
        # discount_rate                     : discount rate. The recommended value by the French government for use in public socio-economic analyses is 4.5%

miscellaneous = pd.read_csv("inputs/miscellaneous.csv", index_col=0, header=None).squeeze("columns")

    # Annualized power capex cost for each tec in M€/GW/year. Formula found in "Low-carbon options for the French power sector: What role for renewables, nuclear energy and carbon capture and storage?", Behrang Shirizadeh & Philippe Quirion, Energy Economics
annuities = pd.read_csv("inputs/construction_time.csv", index_col=0, header=None).squeeze("columns")
for i in annuities.index:
    annuities.at[i] = miscellaneous["discount_rate"]*capex[i]*(miscellaneous["discount_rate"]*construction_time[i]+1)/(1-(1+miscellaneous["discount_rate"])**(-lifetime[i]))

    # Annualized energy capex cost of storage technologies in M€/GWh/year   
storage_annuities = pd.read_csv("inputs/storage_capex.csv", index_col=0, header=None).squeeze("columns")
for i in storage_annuities.index:
    storage_annuities.at[i] = miscellaneous["discount_rate"]*storage_capex[i]*(miscellaneous["discount_rate"]*construction_time[i]+1)/(1-(1+miscellaneous["discount_rate"])**(-lifetime[i]))

"""SET HOUR BY MONTHS

Take the number of hour in the demand file.
Set up hours per months."""

first_month = miscellaneous['first_month']
first_hour = 0
last_hour = len(demand)

hours_by_months = {1: 744, 2: 672, 3: 744, 4: 720, 5: 744, 6: 720, 7: 744, 8: 744, 9: 720, 10: 744, 11: 720, 12: 744}

months_hours = {1: range(0, hours_by_months[first_month])}

j = first_month+1
for i in range(2, 12*nb_years+1):
    hour=months_hours[i-1][-1]+1
    months_hours[i] = range(hour,hour+hours_by_months[j])
    j += 1
    if j == 13:
        j = 1

"""SETS

Definition of set as an object of the model
"""

#Range of hour
model.h = \
    pyo.RangeSet(first_hour,last_hour-1)
#Months
model.months = \
    pyo.RangeSet(1,12*nb_years)
#Technologies
model.tec = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake", "biogas1", "biogas2", "ocgt", "ccgt", "nuc", "h2_ccgt", "phs",  "battery1", "battery4", "methanation", "pyrogazification", "electrolysis", "hydrogen", "methane"])
#Power plants. Only used to calculate sum of generation.
model.gen = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake", "ocgt", "ccgt", "nuc"])
#Variables Technologies
model.vre = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river"])
#Electricity generating technologies
model.balance = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake","nuc","phs","battery1","battery4","h2_ccgt","ocgt","ccgt"])
#Storage Technologies
model.str = \
    pyo.Set(initialize=["phs","battery1","battery4","hydrogen","methane"])
#Battery Storage
model.battery = \
    pyo.Set(initialize=["battery1","battery4"])
#Technologies for upward FRR
model.frr = \
    pyo.Set(initialize=["lake", "phs", "ocgt","ccgt","nuc","h2_ccgt"])

#Dictionnaries which will set a little definition and unit for each technology in the model.
technologies_definition = {
    "offshore_f" : "floating offshore wind",
    "offshore_g" : "ground-based offshore wind",
    "onshore" : "onshore wind", 
    "pv_g" : "pv grounded",
    "pv_c" : "pv commercial",
    "river" : "run-of-river hydro",
    "lake" : "lake and reservoirs",
    "biogas1" : "biogas for ocgt",
    "biogas2" : "biogas for ccgt",
    "ocgt" : "open cycle gas-turbine",
    "ccgt" : "combined cycle gas turbine",
    "nuc" : "nuclear",
    "h2_ccgt" : "combined cycle gas turbine using hydrogen",
    "phs" : "pumped hydroelectric energy storage",
    "battery1" : "1 hour battery",
    "battery4" : "4 hours battery",
    "methanation" : "methane by methanation, into storage",
    "pyrogazification" : "methane by pyrogazification, into storage",
    "electrolysis" : "electrolysis",
    "hydrogen" : "hydrogen removed from storage",
    "methane" : "methane removed from storage",
}

technologies_units = {
    "offshore_f" : "GWh-e",
    "offshore_g" : "GWh-e",
    "onshore": "GWh-e",
    "pv_g" : "GWh-e",
    "pv_c" : "GWh-e",
    "river" : "GWh-e",
    "lake" : "GWh-e",
    "biogas1" : "GWh-th",
    "biogas2" : "GWh-th",
    "ocgt" : "GWh-e",
    "ccgt" : "GWh-e",
    "nuc" : "GWh-e",
    "h2_ccgt" : "GWh-e",
    "phs" : "GWh-e",
    "battery1" : "GWh-e",
    "battery4" : "GWh-e",
    "methanation" : "GWh-th",
    "pyrogazification" : "GWh-th",
    "electrolysis" : "GWh-th",
    "hydrogen" : "GWh-th",
    "methane" : "GWh-th",
}

"""PARAMETERS"""

#Set the hydrogen demand for each hour
H2_demand = {}
for hour in model.h:
    H2_demand[hour] = miscellaneous['H2_demand']

#Set the methane demand for each hour
CH4_demand = {}
for hour in model.h:
    CH4_demand[hour] = miscellaneous['CH4_demand']


"""BOUNDS VALUES

Set initial value for variables.
There is a function for each variable with bounds.
The function return the lower and the upper value.
"""

def capa_bounds(model,i):
    if i in capa_max.keys():
        return (None,capa_max[i])
    elif i == 'phs' :
        return (miscellaneous['phs_discharging_lower'],miscellaneous['phs_discharging_upper'])
    else :
        return(None,None)

def s_bounds(model,i):
    if i == 'phs' :
        return (miscellaneous['phs_charging_lower'],miscellaneous['phs_charging_upper'])
    else :
        return (None,None)

def capacity_bounds(model,i):
    if i == 'phs' :
        return (miscellaneous['phs_energy_lower'],miscellaneous['phs_energy_upper'])
    elif i == 'hydrogen' :
        return (capacity_ex['hydrogen'],None)
    else :
        return (None,None)

"""VARIABLES

Definition of variable as an object of the model
"""

    # Hourly energy generation in GWh/h
model.gene = \
    pyo.Var(((tec, h) for tec in model.tec for h in model.h), within=pyo.NonNegativeReals, initialize=0)

    # Overall yearly installed capacity in GW
model.capa = \
    pyo.Var(model.tec, within=pyo.NonNegativeReals, bounds=capa_bounds)

    # Hourly electricity input of battery storage GW
model.storage = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Energy stored in each storage technology in GWh = Stage of charge
model.stored = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Charging power capacity of each storage technology
model.s = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, bounds=capa_bounds)

    # Energy volume of storage technology in GWh
model.capacity = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, bounds = capacity_bounds)

    # Required upward frequency restoration reserve in GW    
model.reserve = \
    pyo.Var(((reserve, h) for reserve in model.frr for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Hourly unavailable nuclear capacity
try:
    model.capa_nuc_off = \
        pyo.Var(model.h, within=pyo.NonNegativeReals, initialize=0, bounds=(0, fix_capa['nuc']))
except Exception as err:
    raise ValueError("For running the EOLES model with the corrected nuclear flexibility constraints, run the RUN.py file with pyomo solve instead, or fix the installed nuclear capacity in ./inputs/fix_capa.csv. If you want to run a simplified version of EOLES, run Eoles_elec_vf_preprocess instead.")

"""FIXED VALUES"""

for tec in model.tec:
    if tec in fix_capa.keys():
        model.capa[tec].fix(fix_capa[tec])

"""CONSTRAINTS RULE

Set up a function which will return the equation of the constraint.
"""

def generation_vre_constraint_rule(model, h, vre):
    """Get constraint on variables renewable profiles generation."""

    return model.gene[vre, h] == model.capa[vre] * load_factor[vre,h]

def generation_capacity_constraint_rule(model, h, tec):
    """Get constraint on maximum power for non-VRE technologies."""

    return model.capa[tec] >= model.gene[tec,h]
"""
def onshore_capa_bound_constraint_rule(model):
"""
    #Set capacity bound for all onshore wind technologies
"""

    return model.capa["onshore_V90"] + model.capa["onshore_V110"] <= capa_max["onshore"]

def PV_g_capa_bound_constraint_rule(model):
"""
    #Set capacity bound for all grounded PV technologies
"""

    return model.capa["pv_g_ew"] + model.capa["pv_g_ns"] <= capa_max["pv_g"]
"""
def battery1_capacity_constraint_rule(model):
    """Get constraint on capacity of battery1."""

    return model.capa['battery1'] == model.capacity['battery1']

def battery4_capacity_constraint_rule(model):
    """Get constraint on capacity of battery4."""

    return model.capa['battery4'] == model.capacity['battery4']/4

def frr_capacity_constraint_rule(model, h, frr):
    """Get constraint on maximum generation including reserves"""

    return model.capa[frr] >= model.gene[frr, h] + model.reserve[frr, h]

def storing_constraint_rule(model, h, storage_tecs):
    """Get constraint on storing."""

    hPOne = h+1 if h<(last_hour-1) else 0
    charge = model.storage[storage_tecs, h] * eta_in[storage_tecs]
    discharge =  model.gene[storage_tecs, h] / eta_out[storage_tecs]
    flux = charge - discharge
    return model.stored[storage_tecs, hPOne] == model.stored[storage_tecs, h] + flux

def storage_constraint_rule(model,storage_tecs):
    """Get constraint on stored energy to be equal at the end than at the start."""

    first = model.stored[storage_tecs, first_hour]
    last = model.stored[storage_tecs, last_hour-1]
    charge = model.storage[storage_tecs, last_hour-1] * eta_in[storage_tecs]
    discharge = model.gene[storage_tecs, last_hour-1] / eta_out[storage_tecs]
    flux = charge - discharge
    return first == last + flux

def lake_reserve_constraint_rule(model, month):
    """Get constraint on maximum monthly lake generation."""

    return sum(model.gene['lake', hour] for hour in months_hours[month]) <= lake_inflows[month] * 1000

def stored_capacity_constraint(model, h, storage_tecs):
    """Get constraint on maximum energy that is stored in storage units"""

    return model.stored[storage_tecs, h] <= model.capacity[storage_tecs]

def storage_capacity_1_constraint_rule(model, h, storage_tecs):
    """Get constraint on the capacity with hourly charging relationship of storage"""

    return model.s[storage_tecs] >= model.storage[storage_tecs, h]

def battery_capacity_constraint_rule(model,battery):
    """Get constraint on battery's capacity."""

    return model.s[battery] == model.capa[battery]

def biogas_constraint_rule(model):
    """Get constraint on biogas."""

    gene_biogas = sum(model.gene['biogas1', hour]+model.gene['biogas2',hour] for hour in model.h)

    return gene_biogas <= miscellaneous['max_biogas'] * 1000

def hydrogen_balance_constraint_rule(model,h):
    """Get constraint on hydrogen's balance."""

    gene_e_h = model.gene['electrolysis',h]+model.gene['hydrogen',h]
    dem_sto = model.gene['h2_ccgt',h]/miscellaneous['eta_h2_ccgt'] + H2_demand[h] + model.storage['hydrogen',h] + model.gene['methanation',h]*4/miscellaneous['eta_methanation'] #4 h2 are required to produce one CH4
    return gene_e_h == dem_sto

def methane_balance_constraint_rule(model,h):
    """Get constraint on methane's balance."""

    gene_methane = model.gene['methanation',h] + model.gene['biogas1',h] + model.gene['biogas2',h] + model.gene['pyrogazification', h] + model.gene['methane',h]
    dem_sto = model.gene['ocgt',h]/miscellaneous['eta_ocgt'] + model.gene['ccgt',h]/miscellaneous['eta_ccgt'] + CH4_demand[h] + model.storage['methane', h]
    return gene_methane == dem_sto

def reserves_constraint_rule(model, h):
    """Get constraint on frr reserves"""

    res_req = sum(epsilon[vre] * model.capa[vre] for vre in model.vre)
    load_req = demand[h] * miscellaneous['load_uncertainty'] * (1 + miscellaneous['delta'])
    return sum(model.reserve[frr, h] for frr in model.frr) ==  res_req + load_req

def adequacy_constraint_rule(model, h):
    """Get constraint for 'supply/demand relation'"""

    storage = sum(model.storage[str, h] for str in model.str if (str != "hydrogen" and str != "methane"))
    gene_electrolysis = model.gene['electrolysis',h] / miscellaneous['eta_electrolysis']
    return sum(model.gene[balance, h] for balance in model.balance) >= (demand[h] + storage + gene_electrolysis)

def ramping_nuc_up_constraint_rule(model, h):
    """Sets an upper ramping limit for nuclear flexibility"""

    old_h = model.h.last() if h==0 else h-1
    return model.gene['nuc',h] - model.gene['nuc',old_h] <= miscellaneous['hourly_ramping_nuc']*model.capa['nuc']

def ramping_nuc_down_constraint_rule(model, h):
    """Sets a lower ramping limit for nuclear flexibility"""

    old_h = model.h.last() if h==0 else h-1
    return model.gene['nuc',old_h] - model.gene['nuc',h] <= miscellaneous['hourly_ramping_nuc']*model.capa['nuc']

def max_nuc_power_constraint_rule(model, h):
    """Takes into account the reactors stopped for maintenance / refuelling while still allowing for shutdowns during the irradiation period"""

    return model.gene['nuc', h] + model.reserve['nuc', h] <= nuc_max_operating_capa[h] - model.capa_nuc_off[h]

def min_nuc_power_constraint_rule(model, h):
    """Takes into account the reactors stopped for maintenance / refuelling while still allowing for shutdowns during the irradiation period"""

    return model.gene['nuc', h] + model.reserve['nuc', h] >= nuc_min_operating_capa[h] - 0.25*model.capa_nuc_off[h]

###
# This part is purely to replicate a function which is not supported by pyomo.
# The model require a variable model.positive_value which equals model.capa_nuc_off[h]-model.capa_nuc_off[h-1] if positive else 0

model.helper = pyo.Var(model.h, within=pyo.Reals, initialize=0)
model.helper_positive = pyo.Var(model.h, within=pyo.NonNegativeReals, initialize=0)
model.helper_negative = pyo.Var(model.h, within=pyo.NonPositiveReals, initialize=0)

def helper_abs_rule(model, h):
    return model.helper[h] == model.helper_positive[h] + model.helper_negative[h]

def helper_no_cheat_rule(model, h):
    return model.helper_positive[h] <= model.capa_nuc_off[h]

def helper_def_rule(model, h):
    h_old = model.h.last() if h == 0 else h-1 
    return model.helper[h] == model.capa_nuc_off[h] - model.capa_nuc_off[h_old]

model.helper_no_cheat = pyo.Constraint(model.h, rule=helper_no_cheat_rule)
model.helper_abs = pyo.Constraint(model.h, rule=helper_abs_rule)
model.helper_def = pyo.Constraint(model.h, rule=helper_def_rule)
###

def delay_nuc_power_constraint_rule(model, h):
    """Allows for shutdowns during the irradiation period but introduces a delay for next startup due to xenon transient"""

    h_delay = h-miscellaneous['len_delay'] if h >= miscellaneous['len_delay'] else h-miscellaneous['len_delay']+last_hour
    h_old = model.h.last() if h == 0 else h-1
    return model.capa_nuc_off[h] >= model.capa_nuc_off[h_old] - model.helper_positive[h_delay]

def methanation_constraint_rule(model, h):
    """Get constraint on CO2's balance from methanization"""

    return model.gene['methanation', h]/miscellaneous['eta_methanation'] <= (model.gene['biogas1', h] + model.gene['biogas2', h]) * miscellaneous['percentage_co2_from_methanization']

def objective_rule(model):
    """Get constraint for the final objective function."""

    return (sum((model.capa[tec] - existing_capa[tec]) * annuities[tec] * nb_years for tec in model.tec) \
           + sum((model.capacity[storage_tecs]-capacity_ex[storage_tecs]) * storage_annuities[storage_tecs] * nb_years for storage_tecs in model.str) \
           + sum(model.capa[tec] * fOM[tec] * nb_years for tec in model.tec) \
           + sum(model.s[storage_tecs] * (charging_opex[storage_tecs] + charging_capex[storage_tecs]) * nb_years for storage_tecs in model.str) \
           + sum(sum(model.gene[tec, h] * vOM[tec] for h in model.h) for tec in model.tec) \
           + sum(sum(model.reserve[frr, h] * vOM[frr] for h in model.h) for frr in model.frr) \
           )/1000

"""CONSTRAINT CREATION

Create the constraint as an object of the model with the function declared earlier as a rule.
"""

model.generation_vre_constraint = \
    pyo.Constraint(model.h, model.vre, rule=generation_vre_constraint_rule)

model.generation_capacity_constraint = \
    pyo.Constraint(model.h, model.tec, rule=generation_capacity_constraint_rule)
"""
model.onshore_capa_bound_constraint = \
    pyo.Constraint(rule=onshore_capa_bound_constraint_rule)

model.PV_g_capa_bound_constraint = \
    pyo.Constraint(rule=PV_g_capa_bound_constraint_rule)
"""
model.battery_1_capacity_constraint = \
    pyo.Constraint(rule=battery1_capacity_constraint_rule)

model.battery_4_capacity_constraint = \
    pyo.Constraint(rule=battery4_capacity_constraint_rule)

model.frr_capacity_constraint = \
    pyo.Constraint(model.h, model.frr, rule=frr_capacity_constraint_rule)

model.storing_constraint = \
    pyo.Constraint(model.h,model.str, rule=storing_constraint_rule)

model.storage_constraint = \
    pyo.Constraint(model.str, rule=storage_constraint_rule)

model.lake_reserve_constraint = \
    pyo.Constraint(model.months, rule=lake_reserve_constraint_rule)

model.stored_capacity_constraint = \
    pyo.Constraint(model.h, model.str, rule=stored_capacity_constraint)

model.storage_capacity_1_constraint = \
    pyo.Constraint(model.h, model.str, rule=storage_capacity_1_constraint_rule)

model.battery_capacity_constraint = \
    pyo.Constraint(model.battery, rule=battery_capacity_constraint_rule)

model.biogas_constraint = \
    pyo.Constraint(rule=biogas_constraint_rule)

model.hydrogen_balance_constraint = \
    pyo.Constraint(model.h,rule=hydrogen_balance_constraint_rule)

model.methane_balance_constraint = \
    pyo.Constraint(model.h,rule=methane_balance_constraint_rule)

model.reserves_constraint = \
    pyo.Constraint(model.h, rule=reserves_constraint_rule)

model.adequacy_constraint = \
    pyo.Constraint(model.h, rule=adequacy_constraint_rule)

model.ramping_nuc_up_constraint = \
    pyo.Constraint(model.h, rule=ramping_nuc_up_constraint_rule)

model.ramping_nuc_down_constraint= \
    pyo.Constraint(model.h, rule=ramping_nuc_down_constraint_rule)

model.max_nuc_power_constraint= \
    pyo.Constraint(model.h, rule=max_nuc_power_constraint_rule)

model.min_nuc_power_constraint= \
    pyo.Constraint(model.h, rule=min_nuc_power_constraint_rule)

model.delay_nuc_power_constraint= \
    pyo.Constraint(model.h, rule=delay_nuc_power_constraint_rule)

model.methanation_constraint = \
    pyo.Constraint(model.h, rule=methanation_constraint_rule)

#Creation of the objective -> Cost
model.objective = pyo.Objective(rule=objective_rule)

"""SOLVE STATEMENT

Choice of the solver.
You can remove the '#' in the third line to display the output of the solver.
"""

opt = SolverFactory('gurobi')
results = opt.solve(model, options={'Presolve':2, 'LogFile':"grblogfile_eoles_"+model_name})
#model.display()

"""SET OUTPUTS VARIABLES"""

    # The whole demand in TWh
sumdemand = sum(demand[hour] for hour in model.h) / 1000
    # The whole electricity demand for hydrogen in TWh
dem_hydrogen = sum(H2_demand[hour] for hour in model.h) / 1000
    # The whole electricity demand for methane in TWh
dem_methane = sum(CH4_demand[hour] for hour in model.h) / 1000
    # The whole generation in TWh
sumgene = sum(pyo.value(model.gene[gen,hour]) for hour in model.h for gen in model.gen) / 1000

    # Overall yearly energy generated by the technology in TWh
gene_per_tec = {}
for tec in model.tec:
    gene_per_tec[tec] = sum(pyo.value(model.gene[tec,hour]) for hour in model.h) / 1000

    # The whole electricity input for storage in TWh
nSTORAGE = {}
for storage in model.str:
    for hour in model.h:
        nSTORAGE[(storage,hour)] = pyo.value(model.storage[storage,hour])

    # Electricity cost per MWh produced (euros/MWh)
lcoe_sys1 = pyo.value(model.objective)*1000/sumgene

    # Yearly storage related loss in % of power production and in TWh
str_loss_percent = 100*(sum(pyo.value(model.storage[storage,hour]) for storage in model.str for hour in model.h)- \
    sum(gene_per_tec[storage]*1000 for storage in model.str)) / (sumgene*1000)
str_loss_TWh = gene_per_tec['electrolysis']/miscellaneous['eta_electrolysis'] - dem_hydrogen/miscellaneous['eta_electrolysis'] - gene_per_tec['h2_ccgt']
for storage in model.str:
    if storage != 'hydrogen' and storage != 'methane':
        str_loss_TWh += sum(nSTORAGE[storage,hour] for hour in model.h)/1000 - gene_per_tec[storage]

    # Load curtailment in % of power production and in TWh
lc_percent = (100*(sumgene - sumdemand - dem_hydrogen/miscellaneous['eta_electrolysis'])/sumgene) - str_loss_percent
lc_TWh = (sumgene - sumdemand - dem_hydrogen/miscellaneous['eta_electrolysis']) - str_loss_TWh

# Gene - demand = lc + str_loss

    # Dual values
spot_price = {}
for hour in model.h:
    spot_price[hour] = - 1000000 * model.dual[model.adequacy_constraint[hour]]

    # Average cost of hydrogen (euros/kg)
lcoh_1 = pyo.value(model.capa['electrolysis'])*(annuities['electrolysis']+fOM['electrolysis'])
lcoh_2 =  sum(pyo.value(model.gene['electrolysis',hour])*(vOM['electrolysis']+\
    (spot_price[hour]/1000)) for hour in model.h)
lcoh_3 = storage_annuities['hydrogen']*pyo.value(model.capacity['hydrogen'])
lcoh_4 = sum(pyo.value(model.gene['electrolysis',hour]) for hour in model.h)
lcoh = (lcoh_1 + lcoh_2 + lcoh_3)*33.33 / lcoh_4
    # Electricity cost per MWh consumed (euros/MWh)
lcoe_sys2 = (pyo.value(model.objective)-(lcoh*dem_hydrogen/33.33))*1000/sumdemand

elec_cost = {}
for hour in model.h:
    elec_cost[hour] = pyo.value( \
            (sum((model.capa[tec] - existing_capa[tec]) * annuities[tec] / 8760 for tec in model.tec) \
           + sum((model.capacity[storage_tecs]-capacity_ex[storage_tecs]) * storage_annuities[storage_tecs] / 8760 for storage_tecs in model.str) \
           + sum(model.s[storage_tecs] * charging_capex[storage_tecs] / 8760 for storage_tecs in model.str)) \
           + (sum([model.s[storage_tecs] * charging_opex[storage_tecs] * model.gene[storage_tecs, hour] * nb_years / gene_per_tec[storage_tecs] for storage_tecs in model.str if gene_per_tec[storage_tecs] != 0]) \
           + sum([model.capa[tec] * fOM[tec] * model.gene[tec, hour] * nb_years / gene_per_tec[tec] for tec in model.tec if gene_per_tec[tec] != 0]) \
           + sum(model.gene[tec, hour] * vOM[tec] for tec in model.tec) \
           + model.reserve['nuc', hour] * vOM['nuc'] \
           ) / sum(pyo.value(model.gene[tec,hour]) for tec in model.tec))

print("Power capex :")
print(sum((pyo.value(model.capa[tec]) - existing_capa[tec]) * annuities[tec] / 8760 for tec in model.tec) / sum(pyo.value(model.gene[tec,0]) for tec in model.tec))
print("Energy capex :")
print(pyo.value(sum((model.capacity[storage_tecs]-capacity_ex[storage_tecs]) * storage_annuities[storage_tecs] / 8760 for storage_tecs in model.str) / sum(model.gene[tec,0] for tec in model.tec)))
print("Power opex :")
print(pyo.value(sum([model.capa[tec] * fOM[tec] * model.gene[tec, 0] * nb_years / gene_per_tec[tec] for tec in model.tec if gene_per_tec[tec] != 0]) / sum(model.gene[tec,0] for tec in model.tec)))
print("Charging capex :")
print(pyo.value(sum(model.s[storage_tecs] * charging_capex[storage_tecs] / 8760 for storage_tecs in model.str) / sum(model.gene[tec,0] for tec in model.tec)))
print("Charging opex :")
print(pyo.value(sum([model.s[storage_tecs] * charging_opex[storage_tecs] * model.gene[storage_tecs, 0] * nb_years / gene_per_tec[storage_tecs] for storage_tecs in model.str if gene_per_tec[storage_tecs] != 0]) / sum(model.gene[tec,0] for tec in model.tec)))
print("vOM :")
print(pyo.value(sum(model.gene[tec, 0] * vOM[tec] for tec in model.tec) / sum(model.gene[tec,0] for tec in model.tec)))
print("Reserves :")
print(pyo.value(model.reserve['nuc', 0] * vOM['nuc'] / sum(model.gene[tec,0] for tec in model.tec)))

"""OUTPUTS
    There are 4 output files :
        - Summary           : A little summary with the cost and some others data
        - Hourly-Generation : Hourly data
        - Elec_Balance      : Electric Production and Consumption
        - Capacities        : List of capacities by technologies

The try, except loop is here the manage error in the creation of the outputs.
"""

#Summary
summary_file = "outputs/eoles_" + model_name + "_summary.csv"
try:
    with open(summary_file,"w",newline="") as summary:
        summary_writer = csv.writer(summary)

        summary_header = ["COST","LCOH","LCOE_SYS1","LCOE_SYS2","STR_LOSS","LC"]
        summary_writer.writerow(summary_header)

        summary_definition = [
            "in billion euro",
            "average cost of hydrogen (euros/kg)",
            "electricity cost per MWh produced (euros/MWh)",
            "electricity cost per MWh consumed (euros/MWh)",
            "yearly storage related loss in % of power production",
            "load curtailment in % of power production"]
        summary_writer.writerow(summary_definition)

        summary_data = [
            round(pyo.value(model.objective)/nb_years,4),
            round(lcoh,2),
            round(lcoe_sys1,2),
            round(lcoe_sys2,2),
            round(str_loss_percent,2),
            round(lc_percent,2),]
        summary_writer.writerow(summary_data)
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : "+summary_file) 
    else : 
        print("There is an Error (summary) : "+e.args[0])

#Hourly_Generation
hourly_file = "outputs/eoles_" + model_name + "_hourly_generation.csv"
try:
    with open(hourly_file,"w",newline="") as hourly:
        hourly_writer = csv.writer(hourly)
        ###
        hourly_title = ["","Generation ->"]
        for i in range(len(model.tec)-4):
            hourly_title.append("")
        hourly_title += [
            "Consumption ->","","","","",
            "Storage input ->","","","","",
            "State of charge ->","","","","","","",
            "Dual Value",
            "Hourly LCOE",
            "Reserves ->"
            ]
        hourly_writer.writerow(hourly_title)
        ###
        hourly_header = ["hour"]
        for tec in model.tec:
            hourly_header.append(tec)
        hourly_header += [
            "electricity_demand",
            "deficit_prod",
            "phs_in",
            "battery1_in",
            "battery4_in",
            "hydrogen_in",
            "methane_in",
            "phs_charge",
            "battery1_charge",
            "battery4_charge",
            "hydrogen_price",
            "methane_price",
            "nuc_on",
            "nuc_cf",
            "elec balance",
            "elec price"]
        for rsv in model.frr:
            hourly_header.append(rsv)
        hourly_writer.writerow(hourly_header)
        ###
        hourly_definition = [""]
        for tec_def in technologies_definition:
            hourly_definition.append(technologies_definition.get(tec_def))
        hourly_definition += [
            "electricity_demand",
            "demand - production from vre tecs"]
        for storage_tec in model.str:
            hourly_definition.append(technologies_definition.get(storage_tec))
        for storage_tec in model.str:
            hourly_definition.append(technologies_definition.get(storage_tec))
        hourly_definition += [
            "Available nuclear power",
            "NPP fleet-wide capacity factor",
            "/",
            "/"]
        for rsv in model.frr:
            hourly_definition.append(technologies_definition.get(rsv))
        hourly_writer.writerow(hourly_definition)
        ###
        hourly_units = [""]
        for tec_unit in technologies_units:
            hourly_units.append(technologies_units.get(tec_unit))
        hourly_units += [
            "GWhe",
            "GWhe"]
        for storage_tec in model.str:
            hourly_units.append(technologies_units.get(storage_tec))
        for storage_tec in model.str:
            if storage_tec != "hydrogene" or storage_tec != "methane": hourly_units.append(technologies_units.get(storage_tec))
            else: hourly_units += ["Euros/MWh"]
        hourly_units += [
            "%",
            "%",
            "/",
            "€/MWh"]
        for rsv in model.frr:
            hourly_units.append(technologies_units.get(rsv))
        hourly_writer.writerow(hourly_units)
        ###
        for hour in model.h:
            hourly_data = [hour]
            for tec in model.tec:
                hourly_data.append(round(pyo.value(model.gene[tec,hour]),2))

            hourly_data.append(round(demand[hour],2))

            hourly_data.append(round(pyo.value(demand[hour]-sum(model.gene[vre, hour] for vre in model.vre)),2))
            
            for storage_tecs in model.str:
                hourly_data.append(round(pyo.value(model.storage[storage_tecs,hour]),2))
            
            for storage_tecs in model.str:
                hourly_data.append(round(pyo.value(model.stored[storage_tecs,hour]),2))

            nuc_on = nuc_max_operating_capa[hour] - pyo.value(model.capa_nuc_off[hour])
            #hourly_data.append(round(pyo.value(model.capa_nuc_off[hour]), 2)) 
            if pyo.value(model.capa['nuc']) == 0: hourly_data.append(0)
            else: hourly_data.append(round(100*nuc_on/pyo.value(model.capa['nuc']), 2))
            
            #hourly_data.append(round(pyo.value(model.helper_positive[hour]), 2))
            if nuc_on == 0: hourly_data.append(0)
            else: hourly_data.append(round(100*pyo.value(model.gene['nuc', hour])/nuc_on, 2))
            
            hourly_data.append(round(spot_price[hour],2))

            hourly_data.append(round(elec_cost[hour],2))
            
            for frr in model.frr:
                hourly_data.append(round(pyo.value(model.reserve[frr,hour]),2))

            hourly_writer.writerow(hourly_data)
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : "+hourly_file) 
    else : 
        print("There is an Error (hourly) : "+e.args[0])

#Elec_balance
elec_balance_file = "outputs/eoles_" + model_name + "_elec_balance.csv"
try:
    with open(elec_balance_file,"w",newline="") as balance:
        balance_writer = csv.writer(balance)
        balance_title = ["Supply in TWh-e ->"]
        balance_writer.writerow(balance_title)
        balance_tec_minus = ['biogas1','biogas2','hydrogen','electrolysis']
        balance_header = []
        for tec in model.tec:
            if tec not in balance_tec_minus:
                balance_header.append(tec)
        balance_writer.writerow(balance_header)
        balance_definition = []
        for tec in model.tec:
            if tec not in balance_tec_minus:
                balance_definition.append(technologies_definition.get(tec))
        balance_writer.writerow(balance_definition)
        balance_data = []
        for tec in model.tec:
            if tec not in balance_tec_minus:
                balance_data.append(round(pyo.value(gene_per_tec[tec])/nb_years,2))
        balance_writer.writerow(balance_data)
        ################################################
        balance_writer.writerow([])
        balance_title = ["Use in TWh-e ->"]
        balance_writer.writerow(balance_title)
        balance_header = ['electrolysis']
        for tec in model.str:
            if tec != 'hydrogen':
                balance_header.append(tec)
        balance_header += ["elec demand","load curtailment"]
        balance_writer.writerow(balance_header)
        balance_data = [round(pyo.value(gene_per_tec['electrolysis'])/miscellaneous['eta_electrolysis']/nb_years,2)]
        for tec in model.str:
            if tec != 'hydrogen':
                balance_data.append(round(sum(nSTORAGE[tec,hour] for hour in model.h)/1000/nb_years,2))
        balance_data += [round(sumdemand/nb_years,2),round(lc_TWh/nb_years,2)]
        balance_writer.writerow(balance_data)
        #################################################
        balance_writer.writerow([])
        balance_title = ["Miscellaneous->"]
        balance_writer.writerow(balance_title)
        balance_tec = ['str_loss','hydrogen production','h2_demand','CH4_demand','biogas1','biogas2']
        balance_writer.writerow(balance_tec)
        balance_def = ['yearly storage related loss',
        'hydrogen removed from storage','methane removed from storage','elec for h2 demand',
        'biogas for ocgt','biogas for ccgt']
        balance_writer.writerow(balance_def)
        balance_units = ["TWh-e","TWh-th","TWh-th","TWh-e","TWh-th","TWh-th"]
        balance_writer.writerow(balance_units)
        balance_data = [round(str_loss_TWh/nb_years,2),round(pyo.value(gene_per_tec['hydrogen'])/nb_years,2),
        round((dem_hydrogen/miscellaneous['eta_electrolysis'])/nb_years,2),round((dem_methane/miscellaneous['eta_electrolysis'])/nb_years,2),
        round(pyo.value(gene_per_tec['biogas1'])/nb_years,2),round(pyo.value(gene_per_tec['biogas2'])/nb_years,2)]
        balance_writer.writerow(balance_data)
        #####################################################
        balance_writer.writerow([])
        balance_title = ["Capacity Factor in % ->"]
        balance_writer.writerow(balance_title)
        balance_tec = ['lake','ocgt','ccgt','nuc','h2_ccgt']
        balance_writer.writerow(balance_tec)
        balance_data = []
        for tec in model.frr:
            if tec != 'phs':
                if pyo.value(model.capa[tec]) == 0:
                    capa_factor = "-"
                else:
                    capa_factor = round(gene_per_tec[tec]/pyo.value(model.capa[tec])*1000/8760*100/nb_years,2)
                balance_data.append(capa_factor)
        balance_writer.writerow(balance_data)
        ##################################################
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : "+elec_balance_file) 
    else : 
        print("There is an Error (balance) : "+e.args[0])

#Capacities
capacities_file = "outputs/eoles_" + model_name + "_capacities.csv"
try:
    with open(capacities_file,"w",newline="") as capacities:
        capacities_writer = csv.writer(capacities)
        ################################################################
        capacities_title = ["Capacity in GW ->"]
        capacities_writer.writerow(capacities_title)
        capacities_header = []
        for tec in model.tec:
            capacities_header.append(tec)
        capacities_writer.writerow(capacities_header)
        capacities_definition = []
        for tec_def in technologies_definition:
            capacities_definition.append(technologies_definition.get(tec_def))
        capacities_writer.writerow(capacities_definition)
        capacities_data = []
        for tec in model.tec:
            capacities_data.append(round(pyo.value(model.capa[tec]),2))
        capacities_writer.writerow(capacities_data)
        ################################################################
        capacities_writer.writerow([])
        capacities_title = ["Energy volume of storage technology in GWh ->"]
        capacities_writer.writerow(capacities_title)
        capacities_header = []
        for storages_tecs in model.str:
            capacities_header.append(storages_tecs)
        capacities_writer.writerow(capacities_header)
        capacities_definition = []
        for str_def in model.str:
            capacities_definition.append(technologies_definition.get(str_def))
        capacities_writer.writerow(capacities_definition)
        capacities_data = []
        for storages_tecs in model.str:
            capacities_data.append(round(pyo.value(model.capacity[storages_tecs]),2))
        capacities_writer.writerow(capacities_data)
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : "+capacities_file) 
    else : 
        print("There is an Error (capacities) : "+e.args[0])

print("Execution time (EOLES) : " + str(round(time.time() - start_time, 2)) + "s")
